import { PDFDocument, StandardFonts, rgb } from "pdf-lib";
import type { StoredAnalysisRecord } from "../db/analysis-session-store";

export async function generateForensicReportPdf(
  record: StoredAnalysisRecord
): Promise<Buffer> {
  const pdfDoc = await PDFDocument.create();
  pdfDoc.setTitle(`Cipher Sleuth Report ${record.analysisId}`);
  pdfDoc.setAuthor("Cipher Sleuth");
  pdfDoc.setSubject("Digital Image Forensic Report");

  const bodyFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const headingFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

  const pageWidth = 595.28; // A4 width in points
  const pageHeight = 841.89; // A4 height in points
  const margin = 48;
  const contentWidth = pageWidth - margin * 2;
  const bottomBoundary = margin;

  let page = pdfDoc.addPage([pageWidth, pageHeight]);
  let cursorY = pageHeight - margin;

  function addPageIfNeeded(requiredHeight: number): void {
    if (cursorY - requiredHeight < bottomBoundary) {
      page = pdfDoc.addPage([pageWidth, pageHeight]);
      cursorY = pageHeight - margin;
    }
  }

  function wrapText(text: string, fontSize: number): string[] {
    if (!text) {
      return [""];
    }

    const words = text.split(/\s+/).filter(Boolean);
    if (words.length === 0) {
      return [""];
    }

    const lines: string[] = [];
    let currentLine = words[0];

    for (const word of words.slice(1)) {
      const nextLine = `${currentLine} ${word}`;
      const nextWidth = bodyFont.widthOfTextAtSize(nextLine, fontSize);
      if (nextWidth <= contentWidth) {
        currentLine = nextLine;
      } else {
        lines.push(currentLine);
        currentLine = word;
      }
    }

    lines.push(currentLine);
    return lines;
  }

  function drawTextLines(
    text: string,
    fontSize: number,
    options?: { isHeading?: boolean; color?: ReturnType<typeof rgb> }
  ): void {
    const font = options?.isHeading ? headingFont : bodyFont;
    const color = options?.color ?? rgb(0, 0, 0);
    const lineHeight = fontSize * 1.35;
    const lines = wrapText(text, fontSize);

    for (const line of lines) {
      addPageIfNeeded(lineHeight);
      page.drawText(line, {
        x: margin,
        y: cursorY - fontSize,
        size: fontSize,
        font,
        color,
      });
      cursorY -= lineHeight;
    }
  }

  function drawSpacer(height: number): void {
    addPageIfNeeded(height);
    cursorY -= height;
  }

  drawTextLines("Cipher Sleuth Forensic Report", 20, { isHeading: true });
  drawSpacer(6);
  drawTextLines(`Analysis ID: ${record.analysisId}`, 10, {
    color: rgb(0.27, 0.27, 0.27),
  });
  drawTextLines(`Generated At: ${record.generatedAt}`, 10, {
    color: rgb(0.27, 0.27, 0.27),
  });
  drawTextLines(`Original Filename: ${record.filenameOriginal}`, 10, {
    color: rgb(0.27, 0.27, 0.27),
  });
  drawTextLines(`SHA-256: ${record.fileHashSha256}`, 10, {
    color: rgb(0.27, 0.27, 0.27),
  });

  drawSpacer(10);
  drawTextLines("Final Assessment", 14, { isHeading: true });
  drawSpacer(4);
  drawTextLines(`Trust Score: ${record.finalTrustScore}/100`, 11);
  drawTextLines(`Verdict: ${record.forensicBreakdown.verdictLabel}`, 11);
  drawTextLines(
    `Scoring Model: ${record.trustScoreBreakdown.scoringModel} (Weighted Penalty ${record.trustScoreBreakdown.weightedPenaltyScore})`,
    11
  );

  drawSpacer(10);
  drawTextLines("Executive Summary", 14, { isHeading: true });
  drawSpacer(4);
  drawTextLines(record.forensicBreakdown.executiveSummary, 11);

  drawSpacer(10);
  drawTextLines("Orchestrator Risk Signals", 14, { isHeading: true });
  drawSpacer(4);
  for (const signal of record.forensicBreakdown.orchestrator.riskSignals) {
    drawTextLines(`- ${signal}`, 11);
  }

  drawSpacer(10);
  drawTextLines("Agent Summary", 14, { isHeading: true });
  drawSpacer(4);
  for (const agent of record.forensicBreakdown.agentFindings) {
    drawTextLines(
      `- ${agent.agentName} | delta ${agent.trustDelta} | confidence ${agent.confidence} | ${agent.keyFinding}`,
      11
    );
  }

  drawSpacer(10);
  drawTextLines("Scoring Contributions", 14, { isHeading: true });
  drawSpacer(4);
  for (const item of record.trustScoreBreakdown.perAgent) {
    drawTextLines(
      `- ${item.agentId}: raw=${item.rawPenalty}, normalized=${item.normalizedPenalty}, weight=${item.weight}, weighted=${item.weightedPenaltyContribution}`,
      11
    );
  }

  drawSpacer(10);
  drawTextLines(
    "Read-only forensic export generated by Cipher Sleuth. No interactive form fields are embedded.",
    9,
    { color: rgb(0.33, 0.33, 0.33) }
  );

  const pdfBytes = await pdfDoc.save();
  return Buffer.from(pdfBytes);
}
